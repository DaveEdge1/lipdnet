var ontology = (function(){

    // HELPERS
    var _ontology = {
        "inferredVariableType": [],
        "archiveType": [],
        "proxyObservationType": [],
        "units": []
    };

    return {

        // Sort the results of the LinkedEarth Wiki ontology results. Get all the string values from the XML response.
        parseWikiQueryOntology: (function(results, cb){
                try {
                    var _tmp = [];
                    // If there are results, they'll be in this location.
                    // If there aren't results, this location won't exist and we'll trigger the error catch
                    var _data = results.sparql.results[0].result;
                    for(var _m=0; _m<_data.length; _m++) {
                        // console.log(_results[_m]["binding"][0]["literal"][0]);
                        // Push the current data result onto the array
                        _tmp.push(_data[_m]["binding"][0]["literal"][0]);
                    }
                    cb(_tmp);
                } catch(err) {
                    // There was a problem. We don't want to update our ontology if there was an error.
                    // return null instead to show there was a problem.
                    console.log("index.js: parseWikiQueryOntology: No Results? : " + err);
                    cb(null);
                }
            }),

        // Send SPARQL request to LinkedEarth Wiki for ONE ontology field.
        _getWikiOntologyField: (function(field, query){
            // Pack up the options that we want to give the Python request
            var options = {
                uri: "http://wiki.linked.earth/store/ds/query",
                method: 'POST',
                timeout: 3000,
                qs: {"query": query}
            };
            // If we're on the production server, then we need to add in the proxy option
            if (!dev){
                options.proxy = "http://rishi.cefns.nau.edu:3128";
            }
            try{
                // Send out the POST request
                request(options, function (err, res, body){
                    if(err){
                        // There was an error in the response. Don't continue. Return null
                        console.log("index.js: getWikiOntologyField: err response: " + err);
                    }
                    // Response is ugly xml
                    var parseString = require('xml2js').parseString;
                    // Store the body of the response
                    var _xml = res.body;
                    // Parse the XML into a JSON object
                    parseString(_xml, function (err, result) {
                        if(err){
                            console.log("index.js: getWikiOntologyField: parseString: " + err);
                        } else {
                            parseWikiQueryOntology(result, function(arr){
                                if(arr){
                                    _ontology[field] = arr;
                                }
                            });
                        }
                    });
                });
            } catch(err){
                // There was an error before sending out the request.
                // Note the error and move to the next ontology field loop. No ontology data is updated for this field.
                console.log("index.js: getWikiOntologyField: Request failed: " + err);
            }
        }),

        // Use SPARQL queries to get possible field entries for the specific listed fields. From LinkedEarth Wiki
        var getWikiOntology = function(){

                // The prefix to each query is the same.
                var _prefix = "PREFIX core: <http://linked.earth/ontology#>PREFIX wiki: <http://wiki.linked.earth/Special:" +
                    "URIResolver/>PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>";

                // These are the query strings for each of the fields.
                var _fields = {
                    "inferredVariableType": "SELECT distinct ?a WHERE { ?w core:inferredVariableType ?t. ?t rdfs:label ?a }",
                    "archiveType": "SELECT distinct ?a WHERE {{ ?dataset wiki:Property-3AArchiveType ?a. }UNION{ ?w core:proxyArchiveType ?t. ?t rdfs:label ?a }}",
                    "proxyObservationType": "SELECT distinct ?a WHERE { ?w core:proxyObservationType ?t. ?t rdfs:label ?a }",
                    "units": "SELECT distinct ?b WHERE { ?w core:inferredVariableType ?a. ?w core:hasUnits ?b . { ?a rdfs:label \"Age\" . }UNION { ?a rdfs:label \"Year\" . }}",
                };

                // Send out a query request for each of the fields we're keeping a local copy of.
                for(var field in _fields){
                    if(_fields.hasOwnProperty(field)){
                        // Go send the POST request for this field.
                        _getWikiOntologyField(field, _prefix + _fields[field]);
                    }
                }
            };

        // Run once on initialization. All other updates are done on the timer below.
        getWikiOntology();
        // Refresh the LinkedEarth Wiki ontology data every 1 week
        setTimeout(getWikiOntology, 5000);

    }; // end return

}());


module.exports = ontology;
