#!/usr/bin/env node

// var gladstone = require('./gladstone.js');
// var argv = require('yargs').argv;
//
// gladstone.createBagDirectory(argv)


var crypto = require('crypto');
var path = require('path');
var recursive = require('recursive-readdir');
var ncp = require('ncp').ncp;
var fs = require('fs');

var strings = require('./lib/strings');
var bagInfo = require('./lib/bag-info');
var settings = require('./lib/settings');
var lastdirpath = require('./lib/lastdirpath');
var processArgs = require('./lib/process-args');

var gladstone = function(dir){
  return gladstone.createBagDirectory(dir);
};

gladstone.createBagDirectory =  function (args) {
    var procArgs = processArgs(args);
    return new Promise(function (resolve, reject) {
      gladstone.stepOne(procArgs, function(){
        console.log("step two");
        gladstone.createManifest(procArgs.bagName, procArgs, 'tagmanifest');
        setTimeout(function () {
          console.log("resolving");
            resolve(true);
        }, 200);
      });
    });

};

gladstone.stepOne = function(args, cb){
  console.log("step one");
  fs.mkdir(args.bagName, function (err) {
      if (err) {
          console.error(strings.errorBagCreation);
          console.log(err);
      }
      fs.mkdir(args.bagName + '/data', function (err) {
          if (err) throw err;
          console.log(strings.createdData + args.bagName + '/data');
          gladstone.writeBagInfo(args);
          gladstone.copyOriginToData(args);
      });
      console.log(strings.createdBag + args.bagName);
      console.log("bagname: " + args.bagName);
  });

  var _ready = false;
  while(!_ready){
    _ready = gladstone.readyForCb(args);
    if(_ready){
      cb();
    }
  }
};

gladstone.readyForCb = function(args){
  console.log("READY FOR CB?");
  var _count = 0;
  var _txts = [
    args.originDirectory, args.bagName + '/' + 'bagit.txt',
    args.originDirectory, args.bagName + '/' + 'manifest-md5.txt',
    args.originDirectory, args.bagName + '/' + 'bag-info.txt'];
  var files = fs.readdirSync(path);
  console.log(path);
  console.log(files);
  files.forEach(function(file){
    console.log("FILE: " + file);
     if(_txts.includes(file)) {
       var _stats = fs.statSync(file);
       if(_stats){
         console.log(_count);
         _count += 1;
       }
     }
  });
  if (_count === 3){
    console.log("READY!");
    return true;
  } else {
    console.log("NOT READY");
    return false;
  }
};

gladstone.writeBagInfo = function (args, bagInfoMetadata) {
    fs.writeFile(args.bagName + '/' + 'bagit.txt', strings.bagIt + "\n", function (err) {
        if (err) {
            return console.error(strings.errorBagInfo);
        }
        console.log(strings.createdBagInfo + args.bagName + '/' + 'bagit.txt');
    });

    fs.writeFile(args.bagName + '/' + 'bag-info.txt',"", function (err) {
        if (err) {
            return console.error(strings.errorBagInfo);
        }
        console.log(strings.createdBagInfo + args.bagName + '/' + 'bag-info.txt');
    });

    for (var i in bagInfo) {
        if (bagInfo[i]) {
            fs.appendFile(args.bagName + '/' + 'bag-info.txt', i + ": " + bagInfo[i] + "\n", function (err) {
                if (err) {
                    return console.error(strings.errorBagInfo);
                }
            });
        }
    }

};


gladstone.copyOriginToData = function (args) {
    // var lastDirPath = lastdirpath.getLastDirPath(args.originDirectory);
    // fs.mkdir(args.bagName + '/data', function (err) {
    //     if (err) throw err;
    // });
    console.log("copying origin files to dest.");
    ncp(args.originDirectory, args.bagName + '/data', function (err) {
        if (err) {
            return console.error(strings.errorCopying);
        }
        gladstone.createManifest(args.bagName + '/data', args, 'manifest');
    });
};

gladstone.getRelativePath = function (filePath) {
    var relPath = filePath.replace(/\\\\/g, '').replace(/\//g, '/');
    var splitName = relPath.split('/data/');
    var relName = relPath.replace(splitName[0], '');

    if (relName.substring(0, 1) == '/') {
        relName = relName.substring(1);
    }
    return relName;
};

/**
 * Functions for creating the manifest file.
 */
gladstone.createManifest = function (myPath, args, type) {
    // 1 Recurse through the path provided and run the createFileHash function on all the files
    var manifestFileName = gladstone.getManifestFileName(args.bagName, args.cryptoMethod, type);
    console.log(strings.writingManifest + manifestFileName);
    console.log(type);
    if (type === 'manifest') {
        recursive(myPath, function (err, files) {
            files.forEach(function (file) {
              console.log("MANIFEST: creating hash: " + file);
              gladstone.createFileHash(file, args, manifestFileName);
            });
        });
    } else if (type === "tagmanifest"){
      var files = fs.readdirSync(myPath);
      console.log(files);
      files.forEach(function(file){
        console.log("Text file: " + file);
         if(path.extname(file) === ".txt" && file) {
           console.log("TAGMANIFEST: creating hash: " + file);
           gladstone.createFileHash(file, args, manifestFileName);
         }
      });
    }
};

gladstone.createFileHash = function (file, args, manifestFileName) {
    // 2 Create a hash for the provided file path and send the results to the appendHashtoManifest function
    console.log("CREATE FILE HASH: " + file);
    var hash = crypto.createHash(args.cryptoMethod);
    var stats = fs.stat(file, function (err, stat) {
        if (!stat.isDirectory()) {
            var stream = fs.createReadStream(file);
            stream.on('data', function (data) {
                hash.update(data, 'utf8');
            });
            stream.on('end', function () {
                var myHash = hash.digest('hex');
                gladstone.appendHashtoManifest(myHash, file, manifestFileName, args);
            });
        }
    });
};

gladstone.appendHashtoManifest = function (hash, file, manifestFileName, args) {
    // 3 Append the combined hash and filename to the manifest file returned by the getManifestFileName function
    var relName = gladstone.getRelativePath(file);
    var manifestLine = hash + ' ' + relName + '\n';
    fs.appendFile(manifestFileName, manifestLine, function (err) {
        if (err) {
            return console.error(strings.errorManifest);
        }
    });
};


gladstone.getManifestFileName = function (bagName, cryptoMethod, type) {
    // 4 Get the full path of the manifest file
    var manifestFileName = bagName + '/' + type + '-' + cryptoMethod + '.txt';
    return manifestFileName;
};

module.exports = gladstone;
